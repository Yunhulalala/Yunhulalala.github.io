<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/favicon_package_v0.16/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/favicon_package_v0.16/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="JavaScript 基础                           书写方式        外链式 在body里面引入外部的js文件 &lt;script src&#x3D;&quot;utils.js&quot;&gt;&lt;&#x2F;script&gt;                         变量和常量        常量的定义 const 常量名">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript">
<meta property="og:url" content="https://yunhulalala.github.io/2022/03/28/JavaScirpt/index.html">
<meta property="og:site_name" content="Yixuan&#39; Blog">
<meta property="og:description" content="JavaScript 基础                           书写方式        外链式 在body里面引入外部的js文件 &lt;script src&#x3D;&quot;utils.js&quot;&gt;&lt;&#x2F;script&gt;                         变量和常量        常量的定义 const 常量名">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-28T08:28:45.000Z">
<meta property="article:modified_time" content="2022-04-11T03:02:28.379Z">
<meta property="article:author" content="Yixuan Zeng">
<meta property="article:tag" content="前端学习">
<meta name="twitter:card" content="summary"><title>JavaScript | Yixuan' Blog</title><link ref="canonical" href="https://yunhulalala.github.io/2022/03/28/JavaScirpt/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Yixuan' Blog</div><div class="header-banner-info__subtitle">Record my learning</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">JavaScript</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-04-11</span></span></div></header><div class="post-body">
        <h1 id="JavaScript-基础"   >
          <a href="#JavaScript-基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h1>
      
        <h2 id="书写方式"   >
          <a href="#书写方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#书写方式" class="headerlink" title="书写方式"></a>书写方式</h2>
      <ul>
<li>外链式<ul>
<li>在body里面引入外部的js文件</li>
<li><code>&lt;script src=&quot;utils.js&quot;&gt;&lt;/script&gt;</code> </li>
</ul>
</li>
</ul>

        <h2 id="变量和常量"   >
          <a href="#变量和常量" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2>
      <ul>
<li>常量的定义<ul>
<li><code>const 常量名称 = 常量取值;</code>(ES6)</li>
</ul>
</li>
<li>变量的定义<ul>
<li>ES5:<code>var name;</code></li>
<li>ES6: <code>let age</code>
        <h3 id="var"   >
          <a href="#var" class="heading-link"><i class="fas fa-link"></i></a><a href="#var" class="headerlink" title="var"></a>var</h3>
      </li>
</ul>
</li>
<li>在函数内部定义一个变量<code>var a = 1;</code>，函数退出的时候就会销毁。声明<code>a = 1;</code>则a为全局变量，在函数外部可以访问。</li>
<li>声明提升，声明变量在使用变量之后，把所有变量声明都拉到函数作用域的顶部</li>
</ul>

        <h3 id="let"   >
          <a href="#let" class="heading-link"><i class="fas fa-link"></i></a><a href="#let" class="headerlink" title="let"></a>let</h3>
      <ul>
<li><p>与<code>var</code>区别</p>
<ol>
<li><strong>let声明的范围是块作用域，而var声明的范围是函数作用域</strong>。在不同的块中声明相同的标识符，是可以允许的。</li>
<li>暂时性死区，不会有声明提升</li>
<li><code>let</code>没有全局声明</li>
</ol>
</li>
<li><p>变量名中不允许出现空格。尤其注意，变量名中不能出现中划线</p>
</li>
</ul>

        <h2 id="变量的数据类型"   >
          <a href="#变量的数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h2>
      
        <h3 id="基本数据类型（值类型）"   >
          <a href="#基本数据类型（值类型）" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本数据类型（值类型）" class="headerlink" title="基本数据类型（值类型）"></a>基本数据类型（值类型）</h3>
      <ul>
<li>string 字符串</li>
<li>number 数值</li>
<li>boolean 布尔值</li>
<li>null 空值</li>
<li>undefined 未定义</li>
<li>BigInt 大型数值</li>
<li>Symbol  </li>
</ul>

        <h3 id="引用数据类型（引用类型）"   >
          <a href="#引用数据类型（引用类型）" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用数据类型（引用类型）" class="headerlink" title="引用数据类型（引用类型）"></a>引用数据类型（引用类型）</h3>
      <ul>
<li>Object 对象<ul>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error </li>
<li>除了那七种基本数据类型之外，其他的都是Object 类型。</li>
</ul>
</li>
</ul>

        <h3 id="string"   >
          <a href="#string" class="heading-link"><i class="fas fa-link"></i></a><a href="#string" class="headerlink" title="string"></a>string</h3>
      
        <h4 id="模板字符串"   >
          <a href="#模板字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4>
      <pre><code>- console.log(我是$&#123;name&#125;,age:$&#123;age&#125;);//ES6 写法。注意语法格式
</code></pre>

        <h4 id="强制类型转"   >
          <a href="#强制类型转" class="heading-link"><i class="fas fa-link"></i></a><a href="#强制类型转" class="headerlink" title="强制类型转"></a>强制类型转</h4>
      <pre><code>1. `toString()`，调用被转化数据类型的**toString**方法。null和undefined没有toString方法
2. `String()`,调用**String()**函数，将转化的的变量作为参数。对于null和undefined，直接转换成&#39;null&#39;&#39;undefined&#39;
3. 隐式类型转换
    1. 字符串拼接，`+`
        - `console.log(&quot;c=&quot;+c);`
</code></pre>

        <h3 id="number"   >
          <a href="#number" class="heading-link"><i class="fas fa-link"></i></a><a href="#number" class="headerlink" title="number"></a>number</h3>
      
        <h4 id="包含"   >
          <a href="#包含" class="heading-link"><i class="fas fa-link"></i></a><a href="#包含" class="headerlink" title="包含"></a>包含</h4>
      <ul>
<li>数值 整数和小数</li>
<li>无穷大（正无穷）：<strong>Infinity</strong> </li>
<li>无穷小（负无穷）：**-Infinity**</li>
<li>NaN 非数值</li>
</ul>

        <h4 id="强制类型转换"   >
          <a href="#强制类型转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4>
      <ul>
<li><code>Number()</code><ul>
<li><code>Number(&#39;12345&#39;)</code>12345</li>
<li><code>Number(&#39;abc&#39;)</code>返回NAN</li>
<li><code>Number(&#39;&#39;)</code>返回0</li>
<li><code>Number(true)</code>返回1</li>
<li><code>Number(false)</code>返回0</li>
<li><code>Number(null)</code>返回0</li>
<li><code>Number(undefined)</code>返回NaN</li>
</ul>
</li>
<li><code>parseInt()</code><ul>
<li>将字符串中有效的整数内容取出</li>
<li><code>parseInt(&#39;123asd&#39;)</code>返回123，</li>
<li>对非string值会将其转换成string，再进行操作</li>
<li><strong>取整</strong></li>
</ul>
</li>
<li><code>parseFloat()</code><ul>
<li>将字符串中有效的浮点数内容取出</li>
</ul>
</li>
<li>隐式类型转化<ul>
<li><code>-0</code></li>
<li><code>*-</code></li>
<li><code>/1</code></li>
<li><code>+0</code>,不可以，可能遇到要跟字符串一起运算</li>
</ul>
</li>
</ul>

        <h4 id="其他进制数字"   >
          <a href="#其他进制数字" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他进制数字" class="headerlink" title="其他进制数字"></a>其他进制数字</h4>
      <ul>
<li>16进制：<code>0x</code>开头</li>
<li>8进制：<code>0</code>开头</li>
<li>2进制：<code>0b</code>开头，不是所有编译器都支持</li>
<li>兼容问题<ul>
<li><code>parseInt(070,10)</code>,表示转换成10进制</li>
</ul>
</li>
<li>浮点数的运算<ul>
<li>引入包：<code>&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/decimal.js/10.2.0/decimal.min.js&quot;&gt;&lt;/script&gt;</code></li>
<li><code>new Decimal(a).add(new Decimal(b)).toNumber()</code>加法  </li>
</ul>
</li>
</ul>

        <h3 id="boolean"   >
          <a href="#boolean" class="heading-link"><i class="fas fa-link"></i></a><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3>
      
        <h4 id="强制类型转换-1"   >
          <a href="#强制类型转换-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#强制类型转换-1" class="headerlink" title="强制类型转换"></a>强制类型转换</h4>
      <ul>
<li><code>Boolean()</code><ul>
<li>数字-&gt;bool, 除了NaN和0，其他的全为true</li>
<li>字符串-&gt;bool，除了’’,其他的全为true</li>
<li>object-&gt;bool,返回true</li>
<li><code>Boolean(null)</code>,返回false</li>
<li><code>Boolean(undefined)</code>,返回false</li>
</ul>
</li>
</ul>

        <h3 id="null-undefined"   >
          <a href="#null-undefined" class="heading-link"><i class="fas fa-link"></i></a><a href="#null-undefined" class="headerlink" title="null undefined"></a>null undefined</h3>
      <ul>
<li>null<ul>
<li>null是一个类型，表示一个为空的对象</li>
<li>typeof(null),返回object</li>
</ul>
</li>
<li>undefined<ul>
<li>声明变量，但是不给变量赋值</li>
<li>typeof(undefined),undefined  </li>
</ul>
</li>
</ul>

        <h3 id="Symbol"   >
          <a href="#Symbol" class="heading-link"><i class="fas fa-link"></i></a><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3>
      <p>Symbol 指的是独一无二的值。每个通过 Symbol() 生成的值都是唯一的。</p>

        <h3 id="BigInt"   >
          <a href="#BigInt" class="heading-link"><i class="fas fa-link"></i></a><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3>
      
        <h3 id="对象"   >
          <a href="#对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象" class="headerlink" title="对象"></a>对象</h3>
      <p>对象是一组无序的相关<strong>属性</strong>和<strong>方法</strong>的集合  </p>
<ul>
<li>对象的的属性<ul>
<li>键(属性名):值(属性值，可以是任何类型的的值)</li>
</ul>
</li>
<li>对象的值是保存在<strong>堆内存</strong>中的，<strong>如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响</strong>。对于引用类型的数据，赋值相当于地址拷贝，两个变量同时指向了同一个堆内存地址。
        <h4 id="对象分类"   >
          <a href="#对象分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象分类" class="headerlink" title="对象分类"></a>对象分类</h4>
      </li>
</ul>
<ol>
<li>内置对象<ul>
<li>Arguments    函数参数集合</li>
<li>Array    数组</li>
<li>Boolean    布尔对象</li>
<li>Math    数学对象</li>
<li>Date    日期时间</li>
<li>Error    异常对象</li>
<li>Function    函数构造器</li>
<li>Number    数值对象</li>
<li>Object    基础对象</li>
<li>RegExp    正则表达式对象</li>
<li>String    字符串对象</li>
</ul>
</li>
<li>浏览器对象<code> BOM DOM console、document</code></li>
<li>自定义对象</li>
</ol>

        <h4 id="基本包装类型"   >
          <a href="#基本包装类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h4>
      <ol>
<li>基本数据类型(number\string\boolean)无法绑定属性和方法</li>
<li>引用数据类型可以绑定数据和方法（String\Number）<br><code>var strObj = new String(&#39;11111&#39;)</code></li>
<li>当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将基本数据类型转换为引用数据类型。<code>str.length</code></li>
</ol>

        <h4 id="String"   >
          <a href="#String" class="heading-link"><i class="fas fa-link"></i></a><a href="#String" class="headerlink" title="String"></a>String</h4>
      <ul>
<li>查找字符串<ul>
<li>indexOf();<ol>
<li><code>索引值 = str.indexOf(想要查询的字符串);</code> <ul>
<li>从前往后找，找不到返回-1</li>
<li>指定第二个参数，用来指定查找的<strong>起始位置</strong><code>索引值 = str.indexOf(想要查询的字符串, [起始位置]);</code></li>
</ul>
</li>
<li><code>索引值 = str.lastIndexOf(想要查询的字符串);</code> <ul>
<li>从后往前找，找不到返回-1</li>
</ul>
</li>
</ol>
</li>
<li>search();<ol>
<li><code>索引值 = str.search(想要查找的字符串);</code>和<code>索引值 = str.search(正则表达式);</code></li>
</ol>
</li>
<li>includes(); 字符串中是否包含指定的内容<ol>
<li><code>布尔值 = str.includes(想要查找的字符串, [position]);</code></li>
</ol>
</li>
<li>startsWith()：字符串是否以指定的内容开头<ol>
<li><code>布尔值 = str.startsWith(想要查找的内容, [position]);</code></li>
</ol>
</li>
<li>endsWith()：字符串是否以指定的内容结尾语法：<ol>
<li><code>布尔值 = str.endsWith(想要查找的内容, [position]);</code>position默认为str.length</li>
</ol>
</li>
</ul>
</li>
<li>获取指定位置的字符<ul>
<li><code>str[]</code> </li>
</ul>
</li>
<li>字符串截取<ul>
<li>slice();不会修改原字符串，而是将截取到的内容返回。<ul>
<li><code>新字符串 = str.slice(开始索引, 结束索引); //索引值。包左不包右。</code></li>
</ul>
</li>
<li>substr();<ul>
<li><code>字符串 = str.substr(开始索引, 截取的长度);</code></li>
</ul>
</li>
</ul>
</li>
<li>字符串转换为数组 <ul>
<li>split();<ul>
<li><code>新的数组 = str.split(分隔符);</code></li>
</ul>
</li>
</ul>
</li>
<li>替换字符串内容<ul>
<li>replace()<ul>
<li><code>新的字符串 = str.replace(被替换的子串，新的子串);</code></li>
<li><code>str2.replace(&#39;today&#39;, &#39;tomorrow&#39;); //只能替换第一个today</code></li>
<li><code>str2.replace(/today/gi, &#39;tomorrow&#39;)); //这里用到了正则，才能替换所有的today</code></li>
</ul>
</li>
</ul>
</li>
<li>repeat()：重复字符串</li>
<li>trim()：去除字符串前后的空白</li>
<li>大小写转换<ul>
<li>toLowerCase();</li>
<li>toUpperCase();</li>
</ul>
</li>
</ul>

        <h4 id="Number"   >
          <a href="#Number" class="heading-link"><i class="fas fa-link"></i></a><a href="#Number" class="headerlink" title="Number"></a>Number</h4>
      <ul>
<li><code>Number.isInteger()</code> 判断是否为整数  <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Number.isInteger() 判断是否为整数</span><br><span class="line">console.log(Number.isInteger(11));//true </span><br><span class="line">console.log(Number.isInteger(123.222));//false</span><br><span class="line">console.log(Number.isInteger(&#x27;11&#x27;));//false</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h4 id="Math"   >
          <a href="#Math" class="heading-link"><i class="fas fa-link"></i></a><a href="#Math" class="headerlink" title="Math"></a>Math</h4>
      <ul>
<li><code>toFixed() </code>小数点后面保留多少位  <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// toFixed() 小数点后面保留多少位</span><br><span class="line">var a= 3.1415926;</span><br><span class="line">a = a.toFixed(3);</span><br><span class="line">console.log(a);//3.142</span><br></pre></td></tr></table></div></figure></li>
<li><code>Math.random()</code>方法生成随机数  <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Math.random()方法生成随机数</span><br><span class="line">//生成 [0, 1) 之间的随机浮点数</span><br><span class="line">console.log(Math.random());</span><br><span class="line">//生成 [0, 5) 之间的随机整数</span><br><span class="line">console.log(Math.floor(Math.random()*5));</span><br><span class="line">//生成 [0, 5] 之间的随机整数</span><br><span class="line">console.log(Math.ceil(Math.random()*5)); </span><br></pre></td></tr></table></div></figure></li>
<li><code>Math.pow(a,b)</code></li>
<li><code>Math.sqrt(a)</code></li>
</ul>

        <h4 id="Date"   >
          <a href="#Date" class="heading-link"><i class="fas fa-link"></i></a><a href="#Date" class="headerlink" title="Date"></a>Date</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const date = new Date();//当前时间：Fri Apr 08 2022 14:58:41 GMT+0800 (中国标准时间)</span><br><span class="line">console.log(date);</span><br><span class="line">const date1 = new Date(&#x27;2021/02/14&#x27;);//2021年2月14日：Sun Feb 14 2021 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">console.log(date1);</span><br><span class="line">const date2 = new Date(&#x27;2012-02-11 14:02&#x27;);</span><br><span class="line">console.log(date2);//Sat Feb 11 2012 14:02:00 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></div></figure>
<ul>
<li>Date获取获取日期和时间的指定部分<ul>
<li><code>getFullYear()</code></li>
<li><code>getMonth()</code>0-11月</li>
<li>····</li>
</ul>
</li>
<li>获取时间戳<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//方式一</span><br><span class="line">const timestamp1 = +new Date();</span><br><span class="line">console.log(timestamp1); // 打印结果举例：1589448165370</span><br><span class="line"></span><br><span class="line">// 方式二：获取 Date 对象的时间戳（较常用的写法）</span><br><span class="line">const timestamp2 = new Date().getTime();</span><br><span class="line">console.log(timestamp2); // 打印结果举例：1589448165370</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p><strong>将时间戳转化为年月日格式</strong><br>    var date = new Date().getTime();//当前时间时间戳<br>    console.log(date);//1649402134805<br>    date = new Date(date);<br>    var year = date.getFullYear();<br>    var month = date.getMonth()+1;<br>    var date1 = date.getDate();<br>    console.log([year,month,date1].join(‘-‘));//2022-4-8</p>

        <h4 id="数组"   >
          <a href="#数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组" class="headerlink" title="数组"></a>数组</h4>
      <ul>
<li>创建数组<ol>
<li>new Array();</li>
<li>Array.of(v1,v2,v3);<br>当参数都只有一个时，前者表示长度，后者为内容</li>
</ol>
</li>
<li>判断是否为数组<code>布尔值 = Array.isArray(被检测的数组);</code><pre><code>  var arr=[1,145,8,22];
  console.log(Array.isArray(arr));//true
</code></pre>
</li>
<li>数组转化成字符串<pre><code>  `console.log(arr.toString());//方式1： 1,145,8,22`
  `console.log(String(arr));//方式2：1,145,8,22`
  `console.log(arr.join(&#39;-&#39;));//方式3：1-145-8-22`
</code></pre>
</li>
<li>将伪数组转化成真数组<code>Array.from(伪数组)</code></li>
<li>基本操作<ol>
<li>添加元素<code>arr[index] = value;</code></li>
<li>获取数组中的元素<code>arr[index]</code></li>
<li>获取数组的长度<code>arr.length</code>,数组的长度可以更改，大于原来长度值为null，小于原来的长度则删除。<em>arguments长度可以修改，但是不能修改里面的值</em></li>
</ol>
</li>
<li>常见方法<ul>
<li>数组元素的添加和删除<ul>
<li><code>push();</code></li>
<li><code>pop();</code></li>
<li><code>shift();</code></li>
<li><code>unshift();</code></li>
<li><code>slice();</code>返回新的数组，不会改变原来的数组</li>
<li><code>splice();</code>从数组中删除指定的一个或多个元素，返回结果为被删除元素组成的新数组</li>
<li><code>fill();</code></li>
</ul>
</li>
<li><strong>数组的合并</strong>（不会改变原数组<ul>
<li><code>concat();</code></li>
<li><code>...</code>展开语法</li>
</ul>
</li>
<li>排序<ul>
<li><code>reverse();</code>反转数组，返回结果为反转后的数组，会改变原数组</li>
<li><code>sort();</code><ul>
<li>无参数时，默认按照<strong>Unicode</strong>编码，从小到大进行排序，会改变原数组</li>
<li>带参数，自定义排序规则<ul>
<li>从小到大排序<code>res = arr.sort((a, b) =&gt; a - b);</code></li>
<li>从到到小排序<code>res = arr.sort((a,b)=&gt;b-a);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数组元素的查找<ul>
<li><code>indexOf();</code></li>
<li><code>lastIndexOf();</code></li>
<li><code>includes();</code></li>
<li><code>find();</code>
        <h4 id="正则表达式"   >
          <a href="#正则表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4>
      正则表达式用于定义一些字符串的规则。计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符合规则的内容提取出来。</li>
</ul>
</li>
</ul>
</li>
<li>正则表达式语法<ul>
<li>限定符<ul>
<li><code>?</code>:表示<code>?</code>前面一个字母可有可无</li>
<li><code>*</code>:表示<code>*</code>前面的字母可以有0至多个</li>
<li><code>+</code>:表示<code>+</code>前面的字母可以有1至多个</li>
<li><code>&#123;&#125;</code>:指定<code>&#123;&#125;</code>前面的字母出现的次数，<code>&#123;2,6&#125;</code>表示出现2到6次，<code>&#123;2,&#125;</code>表示出现两次以上。<code>&#123;2&#125;</code>表示出现两次<br>【注】：多字符匹配，需要加<code>()</code></li>
</ul>
</li>
<li>运算符<ul>
<li><strong>或</strong>:<code>[]</code>、<code>|</code><ul>
<li><code>[a-z]</code>表示所有的小写英文字符</li>
<li><code>[a-zA-Z]</code>表示所有的英文字符</li>
<li><code>[a-zA-Z0-9]</code>表示所有的英文字符和数字</li>
</ul>
</li>
<li><strong>非</strong>:<code>[^]</code></li>
</ul>
</li>
<li>元字符<ul>
<li><code>\d</code> 数字字符</li>
<li><code>\w</code> 单词字符（英文、数字及下划线)</li>
<li><code>\s</code> 空白符（包含Tab和换行符)</li>
<li><code>\D\W\S</code>大写表示反义</li>
<li><code>.</code> 表示任意字符，除了换行符</li>
<li><code>^a</code> 表示匹配行首的a</li>
<li><code>a$</code> 表示匹配行尾的a</li>
</ul>
</li>
<li>贪婪与懒惰匹配<ul>
<li><code>.*</code>  尽可能匹配多的字符</li>
<li><code>.*?</code> 尽可能匹配少的字符</li>
</ul>
</li>
</ul>
</li>
<li>创建正则表达式的对象<ol>
<li>构造函数创建：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reg = new RegExp(&quot;正则表达式&quot;);</span><br><span class="line">var reg = new RegExp(&quot;正则表达式&quot;, &quot;匹配模式&quot;);</span><br></pre></td></tr></table></div></figure>
匹配模式’g’：表示全局模式，但是test()方法会有问题，生成一个lastindex参数来存储匹配最后一次的位置。<br>匹配模式’i’： 忽略大小写。这里的 i 指的是 ignore。</li>
<li>使用字面量创建: <code>var 变量 = /正则表达式/匹配模式</code><strong>没有引号</strong></li>
</ol>
</li>
<li>RegExp对象正则表达式方法<ol>
<li> <code>test()</code> 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</li>
<li><code>exec()</code>方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。</li>
</ol>
</li>
</ul>

        <h2 id="运算符"   >
          <a href="#运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2>
      <ul>
<li>typeof<ul>
<li><code>typeof a</code></li>
<li><code>typeof(a)</code>
        <h3 id="算数运算符"   >
          <a href="#算数运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#算数运算符" class="headerlink" title="算数运算符+ - * / %"></a>算数运算符<code>+ - * / %</code></h3>
      </li>
</ul>
</li>
<li>对于非Number类型的值进行运算时，<strong>会先将这些值转换成Number然后进行运算</strong>,任何值和NaN做运算都会得NaN</li>
<li><code>+</code>【特殊】<ul>
<li>数据相加</li>
<li>字符串拼接，（字符串一个就好） </li>
</ul>
</li>
</ul>

        <h3 id="自增-自减运算符"   >
          <a href="#自增-自减运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#自增-自减运算符" class="headerlink" title="自增/自减运算符"></a>自增/自减运算符</h3>
      <ul>
<li><code>++</code></li>
<li><code>--</code></li>
</ul>

        <h3 id="一元运算符"   >
          <a href="#一元运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3>
      <ul>
<li><code>typeof</code><ul>
<li><code>typeof a</code></li>
<li><code>typeof(a)</code></li>
</ul>
</li>
<li>正负号</li>
</ul>

        <h3 id="逻辑运算符"   >
          <a href="#逻辑运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3>
      <ul>
<li><code>&amp;&amp; || !</code></li>
<li><strong>非布尔值的逻辑运算</strong>，会先将其转换为布尔值，然后再运算，但返回结果是原值<ul>
<li>返回值<ul>
<li><em>与运算</em>：如果第一个值为 false，则执行第一条语句，并直接返回第一个值；不会再往后执行。如果第一个值为 true，则继续执行第二条语句，并返回第二个值（如果所有的值都为 true，则返回的是最后一个值）。<strong>理解：与运算只要有个false就一定是false</strong></li>
<li>如果第一个值为 true，则执行第一条语句，并直接返回第一个值；不会再往后执行。如果第一个值为 false，则继续执行第二条语句，并返回第二个值（（如果所有的值都为 false，则返回的是最后一个值）。<strong>理解：或运算只要有个true就一定是true</strong></li>
</ul>
</li>
<li>用于<strong>容错处理</strong>，<strong>短路运算</strong>  </li>
</ul>
</li>
</ul>

        <h3 id="赋值运算符"   >
          <a href="#赋值运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3>
      <ul>
<li><code>=  +=  -=  *=  /=  %=</code></li>
</ul>

        <h3 id="比较运算符"   >
          <a href="#比较运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;	大于号</span><br><span class="line">&lt;	小于号</span><br><span class="line">&gt;= 	大于或等于</span><br><span class="line">&lt;=  小于或等于</span><br><span class="line">== 	等于</span><br><span class="line">=== 全等于</span><br><span class="line">!=	不等于</span><br><span class="line">!== 不全等于</span><br></pre></td></tr></table></div></figure>
<ul>
<li>返回Boolean值</li>
<li>非数值比较，Number()之后在进行比较</li>
<li><strong>如果符号两侧的值都是字符串时，不会将其转换为数字进行比较。比较两个字符串时，比较的是字符串的Unicode 编码。</strong></li>
<li>任何值和 NaN 做任何比较都是 false</li>
<li><code>==</code>不严谨，会进行隐式转换，<strong>转化成同类型进行比较</strong>，NaN 不和任何值相等，包括他本身，可以用 <code>isNaN()</code>判断  </li>
</ul>

        <h3 id="三元运算符"   >
          <a href="#三元运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3>
      <p><code>条件表达式 ? 语句1 : 语句2;</code></p>

        <h2 id="流程控制语句"   >
          <a href="#流程控制语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2>
      <p>大体与其他语言相同，在ES5中<code>&#123;&#125;</code>只有分组的作用</p>

        <h3 id="选择结构"   >
          <a href="#选择结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3>
      <ul>
<li><code>if else</code></li>
<li><code>switch() case</code><ul>
<li>switch语句是遇到break就结束
        <h3 id="循环结构"   >
          <a href="#循环结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3>
      略</li>
</ul>
</li>
</ul>

        <h2 id="变量、作用域与内存"   >
          <a href="#变量、作用域与内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h2>
      
        <h3 id="作用域"   >
          <a href="#作用域" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3>
      <ul>
<li>在ES5中，一共两种:<ol>
<li>全局作用域：作用于整个 script 标签内部，或者作用于一个独立的 JS 文件。创建的变量都会作为 window 对象的属性保存</li>
<li>函数作用域（局部作用域）：作用于函数内的代码环境。</li>
</ol>
</li>
</ul>

        <h3 id="变量"   >
          <a href="#变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量" class="headerlink" title="变量"></a>变量</h3>
      <ol>
<li>全局变量<ul>
<li>在全局作用域声明的变量，（不建议在函数中不使用var声明作为全局变量</li>
</ul>
</li>
<li>局部变量<ul>
<li>定义在函数作用域</li>
<li>函数的形参</li>
</ul>
</li>
</ol>

        <h3 id="变量声明提升-是声明并没有赋值赋值"   >
          <a href="#变量声明提升-是声明并没有赋值赋值" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量声明提升-是声明并没有赋值赋值" class="headerlink" title="变量声明提升,是声明并没有赋值赋值"></a>变量声明提升,是声明并没有赋值赋值</h3>
      <p>由于JS的<strong>预解析</strong>，会将JS 代码中所有<strong>变量的定义</strong>和<strong>函数的定义</strong>，放到所有代码的最前面。（<strong>函数表达式不会被声明提升</strong>）</p>
<ul>
<li>函数中，使用 var 关键字声明的变量，会在函数中所有的代码执行之前被声明。</li>
<li><strong>函数中，没有 var 声明的变量都是全局变量，而且并不会提前声明。</strong></li>
<li>JavaScript 没有块级作用域（ES6 之前）,ES6引入<code>let</code></li>
</ul>

        <h3 id="作用域链"   >
          <a href="#作用域链" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3>
      <p>内部函数访问外部函数的变量，采用的是链式查找的方式来决定取哪个值，这种结构称之为作用域链。查找时，采用的是<strong>就近原则</strong>。</p>

        <h2 id="函数"   >
          <a href="#函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数" class="headerlink" title="函数"></a>函数</h2>
      <p>函数是一个对象,使用<code>typeof</code>检查函数对象，返回<strong>function</strong></p>

        <h3 id="定义"   >
          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义" class="headerlink" title="定义"></a>定义</h3>
      <ol>
<li><strong>function</strong>关键词定义函数<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function 函数名([形参1,形参2...形参N])</span><br><span class="line">&#123;</span><br><span class="line">    语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>匿名函数<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var 变量名  = function([形参1,形参2...形参N])</span><br><span class="line">&#123;</span><br><span class="line">语句....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>构造函数<br><code>var 变量名/函数名  = new Function(&#39;形参1&#39;, &#39;形参2&#39;, &#39;函数体&#39;);</code><br>不介意使用（1、写法麻烦 2、执行效率低）</li>
</ol>

        <h3 id="箭头函数"   >
          <a href="#箭头函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3>
      <ul>
<li>语法<ul>
<li><code>let double = (x,y) =&gt; &#123; return x * y; &#125;;</code>多个参数需要()</li>
<li><code>let double = x =&gt; &#123; return 2 * x; &#125;;</code>只有一个参数可以不用写括号</li>
<li><code>let getRandom = () =&gt; &#123; return Math.random(); &#125;;</code>没有参数需要括号</li>
<li>箭头函数的大括号{}<ul>
<li>使用{}，一个函数中就可以包含多条语句</li>
<li>不使用{}，只能由一行代码，且会隐式返回这行代码的值,如果没有返回值则返回一个undefined</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="函数调用"   >
          <a href="#函数调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3>
      <ol>
<li> <code>函数名();</code></li>
<li>通过调用对象的方法<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">	a: &#x27;xixixi&#x27;,</span><br><span class="line">	fn2: function() &#123;</span><br><span class="line">		console.log(&#x27;11111!&#x27;);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn2(); // 调用函数</span><br></pre></td></tr></table></div></figure></li>
<li>立即执行函数<br><code>(function() &#123;console.log(&#39;我是立即执行函数&#39;);&#125;)();</code><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function(a, b) &#123;</span><br><span class="line">    console.log(&quot;a = &quot; + a);</span><br><span class="line">    console.log(&quot;b = &quot; + b);</span><br><span class="line">&#125;)(123, 456);</span><br></pre></td></tr></table></div></figure></li>
<li>定时器函数<br><code>setInterval(function()&#123;&#125;,1000)</code>每秒执行一次函数</li>
</ol>

        <h3 id="函数形参、实参"   >
          <a href="#函数形参、实参" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数形参、实参" class="headerlink" title="函数形参、实参"></a>函数形参、实参</h3>
      <ul>
<li>在 JS 中，形参的默认值是 undefined</li>
<li>如果实参的数量少于形参的数量，多余的形参会被定义为 undefined。表达式的运行结果为 NaN(表示不是数值，NaN是Number类型的)。
        <h3 id="函数的返回值"   >
          <a href="#函数的返回值" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3>
      </li>
<li>如果函数中不写return或者是return后面没有任何值，则也会返回undefined</li>
<li>只能返回一个值， </li>
</ul>

        <h3 id="函数名、函数体和函数加载问题"   >
          <a href="#函数名、函数体和函数加载问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数名、函数体和函数加载问题" class="headerlink" title="函数名、函数体和函数加载问题"></a>函数名、函数体和函数加载问题</h3>
      <p>-函数的加载问题：JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。</p>
<ul>
<li>fn() 和 fn 的区别【重要】<ul>
<li>fn()：调用函数。调用之后，还获取了函数的返回值。</li>
<li>fn：函数对象。相当于直接获取了整个函数对象
        <h3 id="类数组arguments"   >
          <a href="#类数组arguments" class="heading-link"><i class="fas fa-link"></i></a><a href="#类数组arguments" class="headerlink" title="类数组arguments"></a>类数组arguments</h3>
      封装实参的对象，是当前函数的内置对象，只能在函数中访问</li>
</ul>
</li>
<li>返回函数实参个数<code>arguments.length</code></li>
<li>返回正在执行的函数<code>arguments.callee</code></li>
<li>修改元素，通过数组下标进行赋值,但是不能改变数组长度  </li>
</ul>

        <h2 id="事件简介"   >
          <a href="#事件简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件简介" class="headerlink" title="事件简介"></a>事件简介</h2>
      <ul>
<li>事件的三要素<ul>
<li>事件源<ul>
<li>获取事件源<code>document.getElementById(“box”); </code></li>
</ul>
</li>
<li>事件<ul>
<li>绑定事件： 事件源box.事件onclick = function(){事件驱动程序};</li>
</ul>
</li>
<li>事件驱动程序<ul>
<li>书写事件驱动程序：关于DOM的操作。</li>
</ul>
</li>
</ul>
</li>
<li>onload <ul>
<li>当页面加载（文本和图片）完毕的时候，触发onload事件。
        <h2 id="DOM-简介和DOM操作"   >
          <a href="#DOM-简介和DOM操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#DOM-简介和DOM操作" class="headerlink" title="DOM 简介和DOM操作"></a>DOM 简介和DOM操作</h2>
      
        <h3 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h3>
      </li>
<li>文档对象模型（Document object Model），操作网页上的元素的API。比如让盒子移动、变色、轮播图等。</li>
<li>节点<ul>
<li>文档节点（文档）：整个 HTML 文档。整个 HTML 文档就是一个文档节点。</li>
<li>元素节点（标签）：HTML标签。</li>
<li>属性节点（属性）：元素的属性。</li>
<li>文本节点（文本）：HTML标签中的文本内容（包括标签之间的空格、换行）。
        <h3 id="获取节点"   >
          <a href="#获取节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h3>
      </li>
</ul>
</li>
</ul>
</li>
<li>元素节点的获取<ul>
<li><code>var div1 = document.getElementById(&quot;box1&quot;); //方式一：通过 id 获取 一个 元素节点（为什么是一个呢？因为 id 是唯一的）</code></li>
</ul>
</li>
<li>DOM访问关系的获取<ul>
<li>父节点<code>节点.parentNode</code></li>
<li>获取兄弟节点<ul>
<li>下一个节点<code>nextSibling</code></li>
<li>下一个元素节点<code>nextElementSibling</code></li>
<li>上一个节点<code>previousSibling</code></li>
<li>下一个元素节点<code>previousElementSibling</code></li>
</ul>
</li>
<li>获取子节点<ul>
<li>firstChild firstElementChild</li>
<li>lastChild  lastElementChild</li>
<li>childNodes <strong>children</strong>
        <h3 id="DOM节点的操作"   >
          <a href="#DOM节点的操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#DOM节点的操作" class="headerlink" title="DOM节点的操作"></a>DOM节点的操作</h3>
      </li>
</ul>
</li>
</ul>
</li>
<li>创建节点<ul>
<li><code>新的标签(元素节点) = document.createElement(&quot;标签名&quot;);</code></li>
<li><code>var a1 = document.createElement(&quot;li&quot;);   //创建一个li标签</code></li>
</ul>
</li>
<li>插入节点</li>
<li>复制节点
        <h3 id="设置节点的属性"   >
          <a href="#设置节点的属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#设置节点的属性" class="headerlink" title="设置节点的属性"></a>设置节点的属性</h3>
      </li>
</ul>

        <h2 id="通过style对象获取和设置行内样式"   >
          <a href="#通过style对象获取和设置行内样式" class="heading-link"><i class="fas fa-link"></i></a><a href="#通过style对象获取和设置行内样式" class="headerlink" title="通过style对象获取和设置行内样式"></a>通过style对象获取和设置行内样式</h2>
      
        <h2 id="事件的绑定和事件对象Event"   >
          <a href="#事件的绑定和事件对象Event" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件的绑定和事件对象Event" class="headerlink" title="事件的绑定和事件对象Event"></a>事件的绑定和事件对象Event</h2>
      <ul>
<li>addEventListener</li>
</ul>

        <h1 id="JavaScript-异步编程"   >
          <a href="#JavaScript-异步编程" class="heading-link"><i class="fas fa-link"></i></a><a href="#JavaScript-异步编程" class="headerlink" title="JavaScript 异步编程"></a>JavaScript 异步编程</h1>
      
        <h2 id="Ajax"   >
          <a href="#Ajax" class="heading-link"><i class="fas fa-link"></i></a><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2>
      
        <h2 id="jQuery中的Ajax"   >
          <a href="#jQuery中的Ajax" class="heading-link"><i class="fas fa-link"></i></a><a href="#jQuery中的Ajax" class="headerlink" title="jQuery中的Ajax"></a>jQuery中的Ajax</h2>
      
        <h2 id="json"   >
          <a href="#json" class="heading-link"><i class="fas fa-link"></i></a><a href="#json" class="headerlink" title="json"></a>json</h2>
      <ul>
<li>语法规则<ul>
<li>数据在键值对中、数据由逗号分隔、花括号保存对象、方括号保存数组</li>
</ul>
</li>
</ul>

        <h1 id="ES6"   >
          <a href="#ES6" class="heading-link"><i class="fas fa-link"></i></a><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1>
      
        <h2 id="环境配置"   >
          <a href="#环境配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2>
      
        <h3 id="Babel转码器"   >
          <a href="#Babel转码器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Babel转码器" class="headerlink" title="Babel转码器"></a>Babel转码器</h3>
      <p>将ES6代码转为ES5代码</p>

        <h2 id="变量-1"   >
          <a href="#变量-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2>
      
        <h3 id="let-1"   >
          <a href="#let-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#let-1" class="headerlink" title="let"></a>let</h3>
      <ol>
<li><strong>let声明的范围是块作用域，而var声明的范围是函数作用域</strong>。在不同的块中声明相同的标识符，是可以允许的。</li>
<li>没有声明提升，要在声明后使用变量</li>
<li>暂时性死区TDZ（进入当前作用域，变量的使用在声明之前）<ul>
<li>区块中存在 <code>let</code> 和 <code>const</code> 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域,不受外部影响</li>
</ul>
</li>
<li><code>let</code>没有全局声明</li>
<li><code>let</code>不允许在相同作用域内，重复声明同一个变量
        <h2 id="const"   >
          <a href="#const" class="heading-link"><i class="fas fa-link"></i></a><a href="#const" class="headerlink" title="const"></a>const</h2>
      </li>
<li>const一旦声明变量，就必须立即初始化，不能留到以后赋值</li>
<li>作用域与<code>let</code>命令相同</li>
<li>不可以重复声明</li>
<li>
        <h2 id="块级作用域"   >
          <a href="#块级作用域" class="heading-link"><i class="fas fa-link"></i></a><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2>
      </li>
<li>外层作用域无法读取内层作用域的变量，</li>
<li>内层作用域可以定义外层作用域的同名变量</li>
<li>ES5不能在块级作用域定义函数，而ES6允许在在块级作用域之中声明函数，且在块级作用域之外不可引用。</li>
<li>应该避免在块级作用域内声明函数。若有需要也应该写成函数表达式，而不是函数声明语句</li>
</ol>

        <h2 id="数据类型"   >
          <a href="#数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2>
      
        <h3 id="Symbol类型"   >
          <a href="#Symbol类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h3>
      <p>Symbol（符号）是ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p>
<ol>
<li>初始化<ul>
<li><code>let sym = Symbol();</code></li>
<li><code>let fooSymbol = Symbol(&#39;foo&#39;);</code>引入字符串参数作为对符号的描述<br>Symbol()函数不能与new 关键字一起作为构造函数使用。这样做是为了避免创建符<br>号包装对象</li>
</ul>
</li>
<li>
        <h2 id="使用全局符号注册表"   >
          <a href="#使用全局符号注册表" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用全局符号注册表" class="headerlink" title="使用全局符号注册表"></a>使用全局符号注册表</h2>
      
        <h2 id="变量的结构赋值"   >
          <a href="#变量的结构赋值" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2>
      </li>
<li>等号两边的模式相同，左边的变量就会被赋予对应的值<br> <code>var [a,b,c] = [1,2,3]</code>
        <h2 id="函数-1"   >
          <a href="#函数-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2>
      </li>
<li>可以为函数的参数指定默认值
        <h3 id="箭头函数-1"   >
          <a href="#箭头函数-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h3>
      </li>
</ol>

        <h2 id="迭代器和生成器"   >
          <a href="#迭代器和生成器" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2>
      <h3 id=""><a href="#" class="headerlink" title=""></a></h3></div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://yunhulalala.github.io">Yixuan Zeng</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://yunhulalala.github.io/2022/03/28/JavaScirpt/">https://yunhulalala.github.io/2022/03/28/JavaScirpt/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://yunhulalala.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/">前端学习</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/03/31/%E5%8F%8D%E6%80%9D/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">反思</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/03/27/ForeEndInterview/"><span class="paginator-prev__text">FE-INTERVIEW</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">
          JavaScript 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A6%E5%86%99%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">
          书写方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">
          变量和常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          var</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let"><span class="toc-number">1.2.2.</span> <span class="toc-text">
          let</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">
          变量的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          基本数据类型（值类型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          引用数据类型（引用类型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-number">1.3.3.</span> <span class="toc-text">
          string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">
          模板字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">
          强制类型转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#number"><span class="toc-number">1.3.4.</span> <span class="toc-text">
          number</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%90%AB"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">
          包含</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">
          强制类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">
          其他进制数字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boolean"><span class="toc-number">1.3.5.</span> <span class="toc-text">
          boolean</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">
          强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-undefined"><span class="toc-number">1.3.6.</span> <span class="toc-text">
          null undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol"><span class="toc-number">1.3.7.</span> <span class="toc-text">
          Symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigInt"><span class="toc-number">1.3.8.</span> <span class="toc-text">
          BigInt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.9.</span> <span class="toc-text">
          对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">
          对象分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">
          基本包装类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">1.3.9.3.</span> <span class="toc-text">
          String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number"><span class="toc-number">1.3.9.4.</span> <span class="toc-text">
          Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math"><span class="toc-number">1.3.9.5.</span> <span class="toc-text">
          Math</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Date"><span class="toc-number">1.3.9.6.</span> <span class="toc-text">
          Date</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.9.7.</span> <span class="toc-text">
          数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.9.8.</span> <span class="toc-text">
          正则表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">
          运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.1.</span> <span class="toc-text">
          算数运算符+ - * &#x2F; %</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E-%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.2.</span> <span class="toc-text">
          自增&#x2F;自减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">
          一元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.4.</span> <span class="toc-text">
          逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.5.</span> <span class="toc-text">
          赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.6.</span> <span class="toc-text">
          比较运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.7.</span> <span class="toc-text">
          三元运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.</span> <span class="toc-text">
          流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">
          选择结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">
          循环结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-number">1.6.</span> <span class="toc-text">
          变量、作用域与内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">
          作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">
          变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87-%E6%98%AF%E5%A3%B0%E6%98%8E%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%B5%8B%E5%80%BC%E8%B5%8B%E5%80%BC"><span class="toc-number">1.6.3.</span> <span class="toc-text">
          变量声明提升,是声明并没有赋值赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">1.6.4.</span> <span class="toc-text">
          作用域链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">
          函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">
          定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">
          箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">
          函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E3%80%81%E5%AE%9E%E5%8F%82"><span class="toc-number">1.7.4.</span> <span class="toc-text">
          函数形参、实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.7.5.</span> <span class="toc-text">
          函数的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%90%8D%E3%80%81%E5%87%BD%E6%95%B0%E4%BD%93%E5%92%8C%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.6.</span> <span class="toc-text">
          函数名、函数体和函数加载问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%95%B0%E7%BB%84arguments"><span class="toc-number">1.7.7.</span> <span class="toc-text">
          类数组arguments</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">1.8.</span> <span class="toc-text">
          事件简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-%E7%AE%80%E4%BB%8B%E5%92%8CDOM%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.</span> <span class="toc-text">
          DOM 简介和DOM操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.9.1.</span> <span class="toc-text">
          简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9"><span class="toc-number">1.9.2.</span> <span class="toc-text">
          获取节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.3.</span> <span class="toc-text">
          DOM节点的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.9.4.</span> <span class="toc-text">
          设置节点的属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87style%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F"><span class="toc-number">1.10.</span> <span class="toc-text">
          通过style对象获取和设置行内样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%91%E5%AE%9A%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1Event"><span class="toc-number">1.11.</span> <span class="toc-text">
          事件的绑定和事件对象Event</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">
          JavaScript 异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax"><span class="toc-number">2.1.</span> <span class="toc-text">
          Ajax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jQuery%E4%B8%AD%E7%9A%84Ajax"><span class="toc-number">2.2.</span> <span class="toc-text">
          jQuery中的Ajax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json"><span class="toc-number">2.3.</span> <span class="toc-text">
          json</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6"><span class="toc-number">3.</span> <span class="toc-text">
          ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">
          环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Babel%E8%BD%AC%E7%A0%81%E5%99%A8"><span class="toc-number">3.1.1.</span> <span class="toc-text">
          Babel转码器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-1"><span class="toc-number">3.2.</span> <span class="toc-text">
          变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#let-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">
          let</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">3.3.</span> <span class="toc-text">
          const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.4.</span> <span class="toc-text">
          块级作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">
          数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.1.</span> <span class="toc-text">
          Symbol类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="toc-number">3.6.</span> <span class="toc-text">
          使用全局符号注册表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">3.7.</span> <span class="toc-text">
          变量的结构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-1"><span class="toc-number">3.8.</span> <span class="toc-text">
          函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-1"><span class="toc-number">3.8.1.</span> <span class="toc-text">
          箭头函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">3.9.</span> <span class="toc-text">
          迭代器和生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.9.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author2.png" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/Yunhulalala" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/u/5178193663" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">16</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">7</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Yixuan Zeng</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>